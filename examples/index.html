<!DOCTYPE html>
<html>
<head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable = no" name="viewport">
    <meta charset="utf-8" />
    <title>ZCanvas example</title>
    <script type="text/javascript" src="./assets/images.js"></script>
    <script type="text/javascript" src="../src/util/Helpers.js"></script>
    <script type="text/javascript" src="../src/zgor/ZCanvas.js"></script>
    <script type="text/javascript" src="../src/zgor/ZSprite.js"></script>
    <style type="text/css">
        #debug {
            color: red;
        }
    </style>
</head>
<body>
    <h1>zCanvas demo</h1>
    <div id="demo"><!-- x --></div>
    <p>
        Demo features : auto scrolling background, draggable transparent GitHub logo and
        keyboard controllable spritesheet animation that has collision detection.
    </p>
    <span id="debug">

    </span>
    <script type="text/javascript">

        // STEP 1 : SETUP
        // --------------------------------------

        var debug = document.getElementById( "debug" );

        function log( msg ) {
            debug.innerHTML = msg;
        }

        // create a new zCanvas that renders at 60 fps
        var cvsWidth  = 350;
        var cvsHeight = 350;
        var cvs       = new zgor.ZCanvas( cvsWidth, cvsHeight, true, 60 );

        // append zCanvas to DOM
        document.getElementById( "demo" ).appendChild( cvs.getElement() );

        // STEP 2 : SELF ANIMATING IMAGE EXAMPLE
        // --------------------------------------

        // first sprite will acts as a background
        // (see included "assets.js"-file for the assetBackground-image data)
        var bgWidth  = 400, bgHeight = 1204;
        var bgSprite = new zgor.ZSprite( 0, 0, bgWidth, bgHeight, assetBackground );

        // custom overrides, to demonstrate a simple custom behaviour
        // where animation is perfectly timed (test by switching tabs in
        // the browser, animation stops when switching tabs, but by calculating
        // position by verifying elapsed time, it appears as if the application
        // hasn't been paused. Though you could actually prefer a "pause" depending on context...

        var direction      = 0;    // 0 being down, 1 being up
        var speed          = 2;    // the amount of pixels we move per frame
        var prevStamp      = +new Date();
        var renderInterval = cvs.getRenderInterval();
        var maxYPosition   = bgHeight - cvsHeight;

        bgSprite.update = function( aCanvasContext, aCurrentTimestamp )
        {
            var delta = ( aCurrentTimestamp - prevStamp ); // should roughly equal the render interval of the zCanvas
            prevStamp = aCurrentTimestamp;                 // store last timestamp

            // slide the background either up or down

            var amount = speed / renderInterval * delta;

            if ( direction == 0 ) {
                this.setY( this.getY() - amount );
            }
            else {
                this.setY( this.getY() + amount );
            }
            var currentPosition = this.getY();

            // keep movement within canvas bounds

            if ( currentPosition < -( maxYPosition )) {
                direction = 1;
                this.setY( -maxYPosition );
            }
            else if ( currentPosition > 0 ) {
                direction = 0;
                this.setY( 0 );
            }
        };

        // add the sprite onto the canvas so we can see it
        cvs.addChild( bgSprite );

        // STEP 3 : DRAGGABLE IMAGE SPRITE EXAMPLE
        // ---------------------------------------

        // second sprite > represents a transparent gitHub logo at 75x75 px
        // (see included "assets.js"-file for the assetGitHubLogo-image data)

        var sprite = new zgor.ZSprite( 0, 0, 75, 75, ghLogo, assetGitHubLogo );

        // add the GitHub logo-sprite onto the canvas
        cvs.addChild( sprite );

        // make this sprite draggable so the user can move it around
        sprite.setDraggable( true );

        // STEP 4 : NEW SUBCLASS / SPRITESHEET EXAMPLE
        // -------------------------------------------
        // when writing your application using OOP-paradigms, it makes
        // more sense to create new "classes" for custom zSprite Objects, like such:

        var Hero = function( aX, aY, aWidth, aHeight, aImage )
        {
            this.setX( aX );
            this.setY( aY );
            this.updateImage( aImage, aWidth, aHeight );

            this._maxIndexCount = 5; // hard coded, every 5 frames we step to the next tile in the sprite sheet
        };
        Hero.prototype = new zgor.ZSprite();

        // Hero class variables
        Hero.prototype.direction    = 0;     // 0 = left, 1 = right
        Hero.prototype.running      = false; // is the hero running ?
        Hero.prototype.jumping      = false; // is the hero jumping ?
        Hero.prototype.falling      = true;  // is the hero falling ? (set to true for gravity)
        Hero.prototype.xSpeed       = 0;     // horizontal speed (i.e. walking)
        Hero.prototype.MAX_X_SPEED  = 5;     // maximum horizontal speed in pixels per frame
        Hero.prototype.ySpeed       = 0;     // vertical speed (i.e. jumping/falling)
        Hero.prototype._jumpCount   = 0;     // internal : countdown for determining max jump height reached

        // Hero tile / spritesheet variables
        Hero.prototype._standingTiles = 2;   // three slides for the "standing" animation
        Hero.prototype._runningTiles  = 9;   // ten slides for the "running" animation

        // Hero rendering variables
        Hero.prototype._spriteIndex   = 0;   // internal : which horizontal tile in the sprite sheet is current
        Hero.prototype._spriteRow     = 0;   // internal : which vertical row in the sprite sheet is current
        Hero.prototype._indexCounter  = 0;   // internal : the frame counter that is increased on each frame render
        Hero.prototype._maxIndexCount = 0;   // internal : what is the max number of count before we switch tile

        // public methods

        Hero.prototype.jump = function()
        {
            if ( this.jumping )
                return;

            this.ySpeed     = 5;
            this._jumpCount = 10;
            this.jumping    = true;
            this.falling    = false;
        };

        // override update-method for custom logic
        Hero.prototype.update = function( ctx, timestamp )
        {
            // animation update operations (i.e. switch tile in sheet)
            if ( ++this._indexCounter == this._maxIndexCount )
            {
                ++this._spriteIndex;
                this._indexCounter = 0;
            }

            var maxIndex = this.running ? this._runningTiles : this._standingTiles;

            // loop animation
            if ( this._spriteIndex > maxIndex ) {
                this._spriteIndex = 0;
            }

            // select the right tile row depending on direction and action

            this._spriteRow = hero.direction;
            if ( this.running )
                this._spriteRow += 2;

            // movement

            var prevX = this.getX(), prevY = this.getY();
            var thisWidth = this.getWidth(), thisHeight = this.getHeight();

            // are we moving horizontally ?

            if ( this.xSpeed !== 0 )
            {
                this.setX( Math.round( prevX + this.xSpeed ));

                // keep in bounds (exiting screen on left/right result in appearing on right/left)

                var myPos = this.getX();

                if ( myPos > ( cvsWidth + thisWidth )) {
                    this.setX( -thisWidth );
                }
                if ( myPos < -thisWidth) {
                    this.setX( cvsWidth + thisWidth - 1 );
                }
            }

            // updating movement : are we moving vertically ? (currently only a jump up )

            if ( !this.falling && this.jumping )
            {
                this.setY( prevY - this.ySpeed );
            }
            else {
                this.setY( prevY + 7 ); // 7 = default gravity
            }

            // keep in vertical bounds
            if ( this.getY() > this.canvas.getHeight() + thisHeight )
            {
                this.setY( -thisHeight );
            }

            // collision detection : first up get all collidable objects in our direct vicinity
            var sprites = this.canvas.getChildrenUnderPoint( this.getX(), this.getY(), thisWidth, thisHeight, true );

            if ( sprites.length > 0 )
            {
                var amt = sprites.length;

                while ( amt-- )
                {
                    // use faster (but less precise) bounding box check as it suffices for this example
                    var sprite          = sprites[ amt ];
                    var checkHorizontal = true;

                    if ( this.collidesWithEdge( sprite, 3 ))
                    {
                        var targetY = sprite.getY() - thisHeight; // perfect align on top / i.e. "standing on floor"

                        if ( targetY < prevY ) {
                            targetY = sprite.getY() + sprite.getHeight() - thisHeight;
                        }
                        else {
                            checkHorizontal = false;
                        }
                        this.setY( targetY );
                        this.jumping    = false;
                    }
                    else if ( this.collidesWithEdge( sprite, 1 )) {
                        this.setY( prevY );
                    }

                    if ( !checkHorizontal )
                        continue;

                    if ( this.collidesWithEdge( sprite, 2 ) ||
                         this.collidesWithEdge( sprite, 0 ))
                    {
                        this.setX( prevX );
                    }
                }
            }

            // in case the user has stopped moving the hero, we
            // slowly reduce the heros speed so he doesn't stop at once

            if ( !this.running )
            {
                if ( this.xSpeed < 0 ) {
                    this.xSpeed += .25;
                }
                else if ( this.xSpeed > 0 ) {
                    this.xSpeed -= .25;
                }
            }

            // in case the user has stopped holding the jump button down, we
            // slowly reduce the heros speed so he falls back down
            if ( this.jumping && !this.falling && --this._jumpCount <= 0 )
            {
                this.falling = true;
            }
        };

        // override draw-method for custom logic
        Hero.prototype.draw = function( ctx, timestamp )
        {
            var bounds = this.bounds;

            ctx.drawImage( this._image,
                           this._spriteIndex * bounds.width,    // tile x offset
                           this._spriteRow * ( bounds.height + 1 ),     // tile y offset
                           bounds.width, bounds.height,         // tile width and height
                           bounds.left, bounds.top, bounds.width, bounds.height );
        };

        // create a new Hero and add it to the stage
        // our spritesheet is 380 x 70 pixels with each individual tile
        // in the sheet being 38 x 35 pixels
        // (see included "assets.js"-file for the assetSpriteSheet-image data)

        var hero = new Hero( 100, cvsHeight / 2, 38, 35, assetSpriteSheet );
        cvs.addChild( hero );

        // STEP 5 : ADDING KEYBOARD INTERACTION
        // ------------------------------------

        var heroHandler = new util.EventHandler(); // create a handler for all key listeners

        heroHandler.addEventListener( window, "keydown", function( e )
        {
            switch ( e.keyCode )
            {
                // move up (jump)
                case 38:

                    hero.jump();
                    break;

                // move hero to the right
                case 39:
                    hero.direction = 1;

                    if ( hero.xSpeed < hero.MAX_X_SPEED )
                        ++hero.xSpeed;

                    hero.running = true;
                    break;

                // move hero to the left
                case 37:
                    hero.direction = 0;
                    if ( hero.xSpeed > -hero.MAX_X_SPEED ) {
                        --hero.xSpeed;
                    }
                    hero.running = true;
                    break;
            }
        });

        // add a listener for key up (release) so we can tell the hero to stop running

        heroHandler.addEventListener( window, "keyup", function( e )
        {
            if ( e.keyCode == 39 || e.keyCode == 37 ) {
                hero.running = false;
            }
        });

        // STEP 6 : A TEST FOR COLLISION DETECTION
        // ---------------------------------------

        var wallLeft = new zgor.ZSprite( 50, Math.round( cvsHeight / 1.5 ), 10, 100, null, true );
        wallLeft.draw = function( ctx, ts )
        {
            ctx.fillStyle = 'rgb(255,128,0)';
            ctx.fillRect(this.getX(),this.getY(),this.getWidth(),this.getHeight());
        };
        cvs.addChild( wallLeft );

        var wallBottom = new zgor.ZSprite( 50, wallLeft.getY() + wallLeft.getHeight(), cvsWidth / 1.5, 10, null, true );
        wallBottom.draw = wallLeft.draw;
        cvs.addChild( wallBottom );

    </script>
</body>
</html>
