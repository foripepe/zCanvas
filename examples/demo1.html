<!DOCTYPE html>
<html>
<head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable = no" name="viewport">
    <meta charset="utf-8" />
    <title>zCanvas animated spritesheet example</title>
    <link rel="stylesheet" href="./assets/styles.css">
    <script type="text/javascript" src="./assets/images.js"></script>
    <!-- include RequireJS to resolve dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.14/require.min.js" type="text/javascript"></script>
</head>
<body>
    <div id="container">
        <h1>zCanvas demo #1: Spritesheets and collisions</h1>
        <div id="demo"><!-- x --></div>
        <p>
            Demo features : auto scrolling background and a keyboard / touchscreen-controllable spritesheet animation
            that uses the fast (and moderately accurate) collision detection-variant (see API docs).
        </p>
        <span id="debug">

        </span>
    </div>
    <script type="text/javascript">

        // resolve dependencies

        var zLoader, zCanvas, zSprite;

        requirejs.config({
            baseUrl : "../dist/",
            urlArgs : "bust=" + Date.now()
        });

        require( [ "zcanvas.amd" ], function( zCanvasLibrary ) {

            // cheap way to make deps global, just for the sake of this demo's simplicity
            // this is of course not the way to use the AMD require pattern ;)

            zLoader = zCanvasLibrary.zLoader;
            zCanvas = zCanvasLibrary.zCanvas;
            zSprite = zCanvasLibrary.zSprite;

            demo(); // start the actual demo
        });

        function demo() {

            // STEP 1 : SETUP
            // --------------------------------------

            var debug = document.getElementById( "debug" );

            function log( msg ) {
                debug.innerHTML = msg;
            }

            var container = document.getElementById( "demo" );

            // get window dimensions

            var w, h;
            if ( window.outerHeight ) {
                w = window.outerWidth;
                h = window.outerHeight;
            }
            else {
                w = document.body.clientWidth;
                h = document.body.clientHeight;
            }

            // create a new zCanvas that renders at 60 fps
            // keep it within the device / browser bounds
            var cvsWidth  = w < 800 ? w * .93 : 800;
            var cvsHeight = h < 350 ? h : 350;

            var cvs = new zCanvas({
                width: cvsWidth,
                height: cvsHeight,
                animate: true,
                fps: 60
            });
            cvs.preventEventBubbling( true );

            // append zCanvas to DOM
            cvs.insertInPage( container );
            cvs.setSmoothing( false );  // pixel art example, make crisp.

            // STEP 2 : SELF ANIMATING IMAGE EXAMPLE
            // --------------------------------------

            // first sprite will acts as a background
            // (see included "assets.js"-file for the assetBackground-image data)
            var bgWidth  = 800, bgHeight = 1067;
            var bgSprite = new zSprite({
                width: bgWidth,
                height: bgHeight,
                bitmap: assetBackground
            });

            // custom overrides, to demonstrate a simple custom behaviour
            // where animation is perfectly timed (test by switching tabs in
            // the browser, animation stops when switching tabs, but by calculating
            // position by verifying elapsed time, it appears as if the application
            // hasn't been paused. Though you could actually prefer a "pause" depending on context...

            var direction      = 0;    // 0 being down, 1 being up
            var speed          = 2;    // the amount of pixels we move per frame
            var prevStamp      = Date.now();
            var renderInterval = cvs.getRenderInterval();
            var maxYPosition   = bgHeight - cvsHeight;

            bgSprite.update = function( aCurrentTimestamp ) {

                var delta = ( aCurrentTimestamp - prevStamp ); // should roughly equal the render interval of the zCanvas
                prevStamp = aCurrentTimestamp;                 // store last timestamp

                // slide the background either up or down

                var amount = speed / renderInterval * delta;

                if ( direction == 0 ) {
                    this.setY( this.getY() - amount );
                }
                else {
                    this.setY( this.getY() + amount );
                }
                var currentPosition = this.getY();

                // keep movement within canvas bounds

                if ( currentPosition < -( maxYPosition )) {
                    direction = 1;
                    this.setY( -maxYPosition );
                }
                else if ( currentPosition > 0 ) {
                    direction = 0;
                    this.setY( 0 );
                }
            };

            // add the sprite onto the canvas so we can see it
            cvs.addChild( bgSprite );

            // STEP 3 : NEW SUBCLASS / SPRITESHEET EXAMPLE
            // -------------------------------------------
            // when writing your application using OOP-paradigms, it makes
            // more sense to create new "classes" for custom zSprite Objects, like such:

            var Hero = function( opts ) {

                Hero.super( this, "constructor", opts ); // construct as a zSprite

                /* Hero instance properties */

                this.direction    = 0;     // 0 = left, 1 = right
                this.running      = false; // is the hero running ?
                this.jumping      = false; // is the hero jumping ?
                this.falling      = true;  // is the hero falling ? (set to true for gravity)
                this.xSpeed       = 0;     // horizontal speed (i.e. walking)
                this.MAX_X_SPEED  = 5;     // maximum horizontal speed in pixels per frame
                this.ySpeed       = 0;     // vertical speed (i.e. jumping/falling)
                this._jumpCount   = 0;     // internal : countdown for determining max jump height reached
            };
            zSprite.extend( Hero ); // Hero extends zSprite

            // public methods
            // --------------

            // makes the hero jump

            Hero.prototype.jump = function() {

                if ( this.jumping )
                    return;

                this.ySpeed     = 5;
                this._jumpCount = 10;
                this.jumping    = true;
                this.falling    = false;
            };

            // makes the hero run left (0) or right (1) at incremental speed

            Hero.prototype.run = function( direction ) {

                this.direction = direction;
                this.running   = true;
                // switch spritesheet animation now we're starting to run
                this.switchAnimation(
                    ( this.direction === 0 ) ? this._sheet[ 2 ] : this._sheet[ 3 ]
                );
            };

            // stops the hero (will slowly move to a halt)

            Hero.prototype.stop = function() {

                this.running = false;
                // switch spritesheet animation now we're stopping the running
                this.switchAnimation(
                    ( this.direction === 0 ) ? this._sheet[ 0 ] : this._sheet[ 1 ]
                );
            };

            // overridden methods
            // ------------------

            // update-method for custom logic
            Hero.prototype.update = function( timestamp ) {

                // animation update operations (i.e. switch tile in sheet)

                this.updateAnimation();

                // movement

                if ( this.running ) {

                    switch ( this.direction ) {

                        case 0:
                            // left
                            if ( hero.xSpeed > -hero.MAX_X_SPEED )
                                hero.xSpeed -= .125;

                            break;

                        case 1:
                            // right
                            if ( hero.xSpeed < hero.MAX_X_SPEED )
                                hero.xSpeed += .125;
                            break;
                    }
                }

                var prevX     = this.getX(), prevY = this.getY(),
                    thisWidth = this.getWidth(), thisHeight = this.getHeight();

                // are we moving horizontally ?

                if ( this.xSpeed !== 0 ) {

                    this.setX( Math.round( prevX + this.xSpeed ));

                    // keep in bounds (exiting screen on left/right result in appearing on right/left)

                    var myPos = this.getX();

                    if ( myPos > ( cvsWidth + thisWidth ))
                        this.setX( -thisWidth );

                    if ( myPos < -thisWidth )
                        this.setX( cvsWidth + thisWidth - 1 );
                }

                // updating movement : are we moving vertically ? (currently only a jump up )

                if ( !this.falling && this.jumping )
                    this.setY( prevY - this.ySpeed );
                else
                    this.setY( prevY + 7 ); // 7 = default gravity

                // keep in vertical bounds
                if ( this.getY() > this.canvas.getHeight() + thisHeight )
                    this.setY( -thisHeight );

                // collision detection : first up get all collidable objects in our direct vicinity
                var sprites = this.canvas.getChildrenUnderPoint( this.getX(), this.getY(), thisWidth, thisHeight, true );

                if ( sprites.length > 0 ) {

                    var amt = sprites.length;

                    while ( amt-- ) {

                        // use faster (but less precise) bounding box check as it suffices for this example
                        var sprite          = sprites[ amt ];
                        var checkHorizontal = true;

                        if ( this.collidesWithEdge( sprite, 3 )) {

                            var targetY = sprite.getY() - thisHeight; // perfect align on top / i.e. "standing on floor"

                            if ( targetY < prevY ) {

                                if ( !this.collidesWithEdge( sprite, 1 ) &&
                                     !this.collidesWithEdge( sprite, 0 )) {
                                    // we're jumping INTO another object
                                    targetY = sprite.getY() + sprite.getHeight() - thisHeight;
                                }
                                else {
                                    targetY = prevY; // jumped against, halt movement
                                }
                            }
                            else {
                                // we're allowed to "jump", horizontal blocking not applicable for THIS collision
                                checkHorizontal = false;
                            }
                            this.setY( targetY );
                            this.jumping = false;
                        }
                        else if ( this.collidesWithEdge( sprite, 1 )) {
                            this.setY( prevY );
                        }

                        if ( !checkHorizontal )
                            continue;

                        if ( this.collidesWithEdge( sprite, 2 ) ||
                             this.collidesWithEdge( sprite, 0 )) {
                            this.setX( prevX );
                        }
                    }
                }

                // in case the user has stopped moving the hero, we
                // slowly reduce the heros speed so he doesn't stop at once

                if ( !this.running ) {

                    if ( this.xSpeed < 0 )
                        this.xSpeed += .25;

                    else if ( this.xSpeed > 0 )
                        this.xSpeed -= .25;
                }

                // in case the user has stopped holding the jump button down, we
                // slowly reduce the heros speed so he falls back down

                if ( this.jumping && !this.falling && --this._jumpCount <= 0 )
                    this.falling = true;
            };

            // create a new Hero and add it to the stage
            // our spritesheet is 380 x 70 pixels with each individual tile
            // in the sheet being 38 x 35 pixels. There is one row for each animation, there
            // are four rows in total. (see included "images.js"-file for the assetSpriteSheet-image data)

            var tileWidth = 38, tileHeight = 35; // height of a single tile

            var hero = new Hero({
                x: cvsWidth / 2,
                y: cvsHeight / 2,
                width: tileWidth,
                height: tileHeight,
                bitmap: assetSpriteSheet,
                sheet: [
                    { row: 0, col: 0, fpt: 5, amount: 3 },  // standing still, facing left
                    { row: 1, col: 0, fpt: 5, amount: 3 },  // standing still, facing right
                    { row: 2, col: 0, fpt: 5, amount: 10 }, // running, facing left
                    { row: 3, col: 0, fpt: 5, amount: 10 }  // running facing right
                ]
            });
            cvs.addChild( hero );

            // STEP 4 : HOW ABOUT COLLISION DETECTION
            // --------------------------------------

            // we test using the super-fast bounding box collision detection, as such we can
            // afford to make separate sprites of each wall, it's up to your applications needs
            // how you do this (for instance use an unique color for walls and use a single bitmap
            // along with pixel collision detection)

            var wallLeft = new zSprite({
                x: 50, y: Math.round( cvsHeight / 1.75 ), width: 10, height: 100, collidable: true
            });
            cvs.addChild( wallLeft );

            var wallBottom = new zSprite({
                x: 50, y: wallLeft.getY() + wallLeft.getHeight(), width: cvsWidth / 1.5, height: 10, collidable: true
            });
            cvs.addChild( wallBottom );

            var wallRight = new zSprite({
                x: wallBottom.getWidth() + wallLeft.getX() - 10,
                y: wallBottom.getY() - tileHeight,
                width: 10, height: tileHeight, collidable: true
            });

            cvs.addChild( wallRight );

            // something we can jump on
            var wallTopRight = new zSprite({
                x: wallRight.getX(), y: wallRight.getY(), width: 100, height: 10, collidable: true
            });
            cvs.addChild( wallTopRight );

            // custom render logic for each wall
            var wallDrawFn = function( ctx ) {

                ctx.fillStyle = 'rgb(255,128,0)';
                ctx.fillRect( this.getX(), this.getY(), this.getWidth(), this.getHeight());
            };
            wallBottom.draw = wallRight.draw = wallTopRight.draw = wallLeft.draw = wallDrawFn;

            // STEP 5 : ADDING KEYBOARD OR TOUCH INTERACTION
            // ---------------------------------------------

            // we add on-screen controls buttons for touch screens (we cannot test for
            // touchscreens reliably as most browsers support touch events though the DEVICE
            // it is running on hasn't got touch support !

            var leftBtn       = document.createElement( "div" );
            leftBtn.id        = "left-btn";
            leftBtn.innerHTML = "<";

            var rightBtn       = document.createElement( "div" );
            rightBtn.id        = "right-btn";
            rightBtn.innerHTML = ">";

            var jumpBtn       = document.createElement( "div" );
            jumpBtn.id        = "jump-btn";
            jumpBtn.innerHTML = "A";

            container.appendChild( leftBtn );
            container.appendChild( rightBtn );
            container.appendChild( jumpBtn );

            var cancelHandler = function( e ) {
                hero.stop();
            };

            leftBtn.addEventListener ( "touchstart",  function( e ) { hero.run( 0 ); });
            rightBtn.addEventListener( "touchstart",  function( e ) { hero.run( 1 ); });
            jumpBtn.addEventListener ( "touchstart",  function( e ) { hero.jump(); });
            leftBtn.addEventListener ( "touchcancel", cancelHandler );
            leftBtn.addEventListener ( "touchcancel", cancelHandler );
            leftBtn.addEventListener ( "touchend",    cancelHandler );
            rightBtn.addEventListener( "touchend",    cancelHandler );

            // keyboard control for desktop devices

            window.addEventListener( "keydown", function( e ) {

                switch ( e.keyCode ) {

                    // move up (jump)
                    case 38:
                        hero.jump();
                        break;

                    // move hero to the right
                    case 39:
                        if ( !hero.running )
                            hero.run( 1 );
                        break;

                    // move hero to the left
                    case 37:
                        if ( !hero.running )
                            hero.run( 0 );
                        break;
                }
            });

            // add a listener for key up (release) so we can tell the hero to stop running

            window.addEventListener( "keyup", function( e ) {

                if ( e.keyCode == 39 || e.keyCode == 37 ) {
                    hero.stop();
                }
            });
        }

    </script>
</body>
</html>
